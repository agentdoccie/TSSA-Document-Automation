// /api/generate-pdf.js
// Fault-tolerant PDF generation with triple fallback:
// 1) Local PDF (pdf-lib) -> 2) CloudConvert DOCX->PDF -> 3) Return DOCX

import fs from "fs";
import path from "path";
import PizZip from "pizzip";
import Docxtemplater from "docxtemplater";
import CloudConvert from "cloudconvert";
import { PDFDocument, StandardFonts, rgb } from "pdf-lib";
import { Readable } from "stream";

// --- Vercel / Node runtime ---
export const config = { runtime: "nodejs" };

// -------- Utilities --------
const isString = (v) => typeof v === "string";
const nonEmpty = (s) => isString(s) && s.trim().length > 0;

// Safe filename: alnum, space, dash, underscore only
function safeFilename(base, ext = ".pdf") {
  const cleaned = String(base || "document")
    .replace(/[^A-Za-z0-9 _-]/g, "")
    .replace(/\s+/g, "_")
    .slice(0, 60) || "document";
  return `${cleaned}${ext}`;
}

// Convert Buffer to readable stream (for CloudConvert upload)
function bufferToStream(buffer) {
  const stream = new Readable();
  stream.push(buffer);
  stream.push(null);
  return stream;
}

// -------- Step A: Fill the DOCX template in-memory --------
function renderDocxBuffer({ fullName, witness1Name, witness1Email, witness2Name, witness2Email }) {
  // Template lives in /templates/CommonCarryDeclaration.docx (in repo)
  const templatePath = path.join(process.cwd(), "templates", "CommonCarryDeclaration.docx");

  // Read DOCX as binary
  const content = fs.readFileSync(templatePath, "binary");

  // Fill placeholders with docxtemplater
  const zip = new PizZip(content);
  const doc = new Docxtemplater(zip, { paragraphLoop: true, linebreaks: true });

  // Render with safe values
  doc.render({
    FULL_NAME: fullName,
    WITNESS_1_NAME: witness1Name,
    WITNESS_1_EMAIL: witness1Email,
    WITNESS_2_NAME: witness2Name,
    WITNESS_2_EMAIL: witness2Email,
    // Add more placeholders later as needed
  });

  // Return DOCX buffer
  const buffer = doc.getZip().generate({ type: "nodebuffer" });
  return buffer;
}

// -------- Step B: Generate a PDF locally (no external calls) --------
// Note: This uses a clean, professional layout (not Word layout). We do this
// to avoid external dependencies. You can refine the style here anytime.
async function generateLocalPdf({ fullName, witness1Name, witness1Email, witness2Name, witness2Email }) {
  const pdf = await PDFDocument.create();

  // Fonts
  const font = await pdf.embedFont(StandardFonts.Helvetica);
  const bold = await pdf.embedFont(StandardFonts.HelveticaBold);

  const margin = 56; // ~0.78in
  const page = pdf.addPage([595.28, 841.89]); // A4 (points)
  const { width, height } = page.getSize();

  let y = height - margin;

  // Title
  const title = "Common Carry Declaration";
  page.drawText(title, {
    x: margin,
    y,
    size: 20,
    font: bold,
    color: rgb(0.09, 0.18, 0.35),
  });
  y -= 28;

  // Subtitle / intro
  const intro =
    "This declaration was generated by the TSSA Document Automation Portal. " +
    "Please review the details below and proceed according to the applicable process.";
  y = drawWrappedText(page, intro, { x: margin, y, size: 11, font, color: rgb(0, 0, 0), maxWidth: width - margin * 2 });
  y -= 12;

  // Divider
  drawRule(page, margin, y, width - margin);
  y -= 18;

  // Sections
  y = drawLabelValue(page, "Full Name:", fullName, { x: margin, y, font, bold });
  y -= 8;

  y = drawLabelValue(page, "Witness 1 (Name):", witness1Name, { x: margin, y, font, bold });
  y -= 6;
  y = drawLabelValue(page, "Witness 1 (Email):", witness1Email, { x: margin, y, font, bold });
  y -= 12;

  y = drawLabelValue(page, "Witness 2 (Name):", witness2Name, { x: margin, y, font, bold });
  y -= 6;
  y = drawLabelValue(page, "Witness 2 (Email):", witness2Email, { x: margin, y, font, bold });
  y -= 16;

  // Footer note
  const note = "Generated automatically. If you need assistance, contact support.";
  page.drawText(note, { x: margin, y, size: 9, font, color: rgb(0.35, 0.35, 0.35) });

  const pdfBytes = await pdf.save();
  return Buffer.from(pdfBytes);
}

// Helper: draw a label/value pair
function drawLabelValue(page, label, value, { x, y, font, bold }) {
  const labelSize = 12;
  const valueSize = 12;
  page.drawText(label, { x, y, size: labelSize, font: bold, color: rgb(0, 0, 0) });
  const labelWidth = bold.widthOfTextAtSize(label, labelSize);
  const gap = 8;
  const vX = x + labelWidth + gap;
  const maxWidth = page.getSize().width - vX - 56;

  return drawWrappedText(page, value || "-", {
    x: vX,
    y,
    size: valueSize,
    font,
    color: rgb(0, 0, 0),
    maxWidth,
  }) - 6;
}

// Helper: wrapped text drawer
function drawWrappedText(page, text, { x, y, size, font, color, maxWidth }) {
  if (!text) text = "-";
  const words = String(text).split(/\s+/);
  let line = "";
  let cursorY = y;

  const lineHeight = size * 1.35;

  for (const w of words) {
    const test = (line ? line + " " : "") + w;
    const wWidth = font.widthOfTextAtSize(test, size);
    if (wWidth > maxWidth && line) {
      page.drawText(line, { x, y: cursorY, size, font, color });
      cursorY -= lineHeight;
      line = w;
    } else {
      line = test;
    }
  }
  if (line) {
    page.drawText(line, { x, y: cursorY, size, font, color });
    cursorY -= lineHeight;
  }
  return cursorY;
}

function drawRule(page, x1, y, x2) {
  page.drawLine({
    start: { x: x1, y },
    end: { x: x2, y },
    thickness: 0.6,
    color: rgb(0.7, 0.7, 0.7),
  });
}

// -------- Step C: CloudConvert DOCX->PDF (fallback) --------
async function tryCloudConvert(docxBuffer, filenameBase, apiKey) {
  if (!nonEmpty(apiKey)) {
    throw new Error("CloudConvert API key missing");
  }
  const cloudConvert = new CloudConvert(apiKey);

  // Create a job with import -> convert -> export
  const job = await cloudConvert.jobs.create({
    tasks: {
      import: { operation: "import/upload" },
      convert: { operation: "convert", input: "import", output_format: "pdf" },
      export: { operation: "export/url", input: "convert" },
    },
  });

  const importTask = job.tasks.find((t) => t.name === "import");
  const exportTaskName = "export";
  const uploadUrl = importTask.result.form.url;

  // Upload the DOCX (in-memory)
  await cloudConvert.tasks.upload(importTask, bufferToStream(docxBuffer), filenameBase + ".docx");

  // Wait for job to finish
  const finished = await cloudConvert.jobs.wait(job.id);
  const exportTask = finished.tasks.find((t) => t.name === exportTaskName);
  const file = exportTask.result.files[0];

  // Download the PDF
  const response = await fetch(file.url);
  if (!response.ok) {
    throw new Error(`CloudConvert fetch failed: ${response.status}`);
  }
  const pdfBuffer = Buffer.from(await response.arrayBuffer());
  return pdfBuffer;
}

// -------- Main handler --------
export default async function handler(req, res) {
  try {
    if (req.method !== "POST") {
      return res.status(405).json({ error: "Method Not Allowed" });
    }

    // Parse body (JSON expected)
    const { fullName, witness1Name, witness1Email, witness2Name, witness2Email } = (await readJsonBody(req)) || {};

    // Validate minimally; client already enforces required fields
    const bad =
      !nonEmpty(fullName) ||
      !nonEmpty(witness1Name) ||
      !nonEmpty(witness1Email) ||
      !nonEmpty(witness2Name) ||
      !nonEmpty(witness2Email);

    if (bad) {
      return res.status(400).json({ error: "Missing required fields" });
    }

    // Prepare safe base name
    const baseName = safeFilename(`${fullName}_Declaration`, "");

    // 1) Render DOCX in-memory (always do this; used for fallback and for CloudConvert)
    let docxBuffer;
    try {
      docxBuffer = renderDocxBuffer({ fullName, witness1Name, witness1Email, witness2Name, witness2Email });
    } catch (err) {
      console.error("❌ DOCX render failed:", err);
      return res.status(500).json({ error: "Template rendering failed" });
    }

    // 2) Try Local PDF
    try {
      const pdfBuffer = await generateLocalPdf({ fullName, witness1Name, witness1Email, witness2Name, witness2Email });
      const filename = safeFilename(baseName || "document", ".pdf");
      res.setHeader("Content-Type", "application/pdf");
      res.setHeader("Content-Disposition", `attachment; filename="${filename}"`);
      return res.send(pdfBuffer);
    } catch (err) {
      console.error("⚠️ Local PDF generation failed, trying CloudConvert:", err?.message || err);
    }

    // 3) CloudConvert fallback (if key present)
    const ccKey = process.env.CLOUDCONVERT_API_KEY;
    if (nonEmpty(ccKey)) {
      try {
        const pdfBuffer = await tryCloudConvert(docxBuffer, baseName || "document", ccKey);
        const filename = safeFilename(baseName || "document", ".pdf");
        res.setHeader("Content-Type", "application/pdf");
        res.setHeader("Content-Disposition", `attachment; filename="${filename}"`);
        return res.send(pdfBuffer);
      } catch (err) {
        // Explicitly surface 402 (no credits) as a log note, but still fall back to DOCX
        console.error("⚠️ CloudConvert fallback failed:", err?.message || err);
      }
    } else {
      console.warn("ℹ️ No CLOUDCONVERT_API_KEY provided; skipping CloudConvert fallback.");
    }

    // 4) Final fallback: return DOCX so the user still gets a file
    const docxName = safeFilename(baseName || "document", ".docx");
    res.setHeader(
      "Content-Type",
      // Real DOCX content type:
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
    );
    res.setHeader("Content-Disposition", `attachment; filename="${docxName}"`);
    return res.send(docxBuffer);
  } catch (err) {
    console.error("❌ Fatal error in /api/generate-pdf:", err);
    return res.status(500).json({ error: "Unexpected server error" });
  }
}

// Read JSON body safely in Node runtime (no req.json() here)
async function readJsonBody(req) {
  const chunks = [];
  for await (const c of req) chunks.push(c);
  try {
    return JSON.parse(Buffer.concat(chunks).toString("utf8") || "{}");
  } catch {
    return {};
  }
}
